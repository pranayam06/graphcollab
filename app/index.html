<html>
<head>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/litegraph.js/css/litegraph.css">
  <script src="https://cdn.jsdelivr.net/npm/litegraph.js/build/litegraph.min.js"></script>
  <script src="https://cdn.socket.io/4.7.4/socket.io.min.js"></script>
  <style>
    body { margin:0; font-family: sans-serif; display:flex; flex-direction:column; height:100vh; }
    #toolbar {
      display:flex; align-items:center; padding:10px; background:#2c3e50; color:white; gap:10px;
    }
    #toolbar {display:flex; align-items:center;
  padding:15px;
  background:#2c3e50; color:white;
  gap:10px; height:60px;
}
#toolbar button {
  z-index: 10;
  position: relative; 
}
#toolbar input, #toolbar button {
  padding:7px 12px; border:none; border-radius:4px; font-size:14px;
}
    #toolbar button { cursor:pointer; background:#3498db; color:white; }
    #toolbar button:hover { background:#2980b9; }
    #mycanvas { flex:1; border-top:1px solid #ccc; width:100%; display: block; }
    #collaborators li::before {
    content: '';
    display: inline-block;
    width: 10px;
    height: 10px;
    background: #3b4258;
    border-radius: 50%;
    margin-right: 8px;
}
  </style>
</head>
<body>
  <div id="toolbar">
    <input id="userId" placeholder="User ID">
    <input id="roomId" placeholder="Room ID">
    <button id="joinRoomBtn">Join Room</button> 
    <button id="historyBtn" style="margin-left: 700px;">History</button>

  </div>
  <div id="collaborators" style="
  position:absolute;
  top:0; right:0;
  width:200px;
  height:100%;
  background:#b1b2b6;
  padding:10px;
  overflow-y:auto;
  display:none;
"> 
<h3 style="font-size: 1.2em; font-weight: bold; margin-bottom: 10px; margin-left: 8px">
  Collaborators
</h3>
  <ul style="list-style:none; padding:0; margin:0;" id="collaboratorsList">
  </ul>
</div>
<div id="historyPanel" style="
  position:absolute;
  top:0; right:210px;
  width:300px;
  height:100%;
  background:#f5f5f5;
  padding:10px;
  overflow-y:auto;
  display:none;
  border-left:1px solid #ccc;
"> 
<button id="restore" style="margin-bottom:10px;">Restore Version</button>
  <h3>Room History</h3>
  <ul id="historyList" style="list-style:none; padding:0; margin:0;"></ul>
</div>
  <canvas id="mycanvas"></canvas> 
  <div id="overlay" style="
  display:none;
  position:absolute;
  top:0; left:0;
  width:100%;
  height:100%;
  z-index:999;
"></div>

<script type="module"> 
import * as Y from "https://esm.sh/yjs@13"

/* scaling for better resolution  
dpr = device pixels / css pixels 
expands the canvas pixels for greater resolution, and then scales coord system accordingly
*/
const canvasEl = document.getElementById("mycanvas");
const ctx = canvasEl.getContext("2d"); 
const dpr = window.devicePixelRatio || 1;
canvasEl.width = canvasEl.clientWidth * dpr; 
canvasEl.height = canvasEl.clientHeight * dpr;
ctx.scale(dpr, dpr); 

const ydoc = new Y.Doc();
const ymap = ydoc.getMap("graph");
let roomId = null;
let userId = null;
let viewingHistory = false;       // when true, do not send/accept live updates
let currentPreview = null; // stores the version you're previewing
let applyingRemoteUpdate = false; // used to prevents cycles

// helper functions
function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }
function deepEqual(a,b) { return JSON.stringify(a)===JSON.stringify(b); } 

// extended class for tracking specific actions
class LGraphPro extends LGraph {
  constructor() {
    super(); 
    this._graph_cache = {}; 
  }
  
  emit(...args){ 
    if(this.events) {
      this.events.emit(...args); 
    } 
  }

  change(){ 
    super.change(); 
    this.emit("change"); 
    this.checkGraphChange(); 
  }
  
  connectionChange(node){ 
    if(super.connectionChange){ 
      super.connectionChange(node); 
    } 
    this.emit("connection_change", node); 
    this.checkGraphChange(); 
  }
  
  serializeDeep(options={}) {
    const g=this.serialize();
    g.nodes.sort((a,b)=>a.id-b.id);
    if(options.skip_inputs) g.nodes.forEach(x=>x.inputs=[]);
    if(options.skip_outputs) g.nodes.forEach(x=>x.outputs=[]);
    if(options.skip_properties) g.nodes.forEach(x=>x.properties={});
    if(options.skip_links) g.links=[];
    if(options.skip_nodes) g.nodes=[];
    return deepClone(g);
  }
  
  checkGraphChange() {
    if (applyingRemoteUpdate) return; // dont emit change socket when updating remote updates
    if (viewingHistory) return; // don't send edits while reviewing history
    const g = this.serializeDeep({ skip_inputs:true, skip_outputs:true, skip_properties:false });
    if (deepEqual(g, this._graph_cache)) return;
    this._graph_cache = g; 
    if (!ydoc || !roomId || !userId) return; 
    ymap.set("graph", this.serializeDeep());
    const update = Array.from(Y.encodeStateAsUpdate(ydoc)); 
    document.dispatchEvent(new CustomEvent("graph-update", { detail: update }));
  }
}

// Create graph
var graph = new LGraphPro();
var canvas = new LGraphCanvas("#mycanvas", graph); 

/*
code from websocket only iteration (last edit wins)
function listen_for_change(graphJSON) {
  if (!ydoc || !roomId || !userId) return;
  ymap.set("graph", graphJSON);
  const update = Array.from(Y.encodeStateAsUpdate(ydoc));
  document.dispatchEvent(new CustomEvent("graphJSONUpdated", { detail: this.serializeDeep() }));
  socket.emit("graph-update", update);
}


function update_graph(json) {
    applyingRemoteUpdate = true;
    graph.configure(json); 
    console.log(json)
    graph._graph_cache = graph.serializeDeep({ skip_inputs:true, skip_outputs:true, skip_properties:true });
    applyingRemoteUpdate = false;
}
*/

// used for applying incremental updates 1) recieving graph update and 2) recieving current version after viewing history
window.recieve_update = function(arr) {
  const update = new Uint8Array(arr);
  Y.applyUpdate(ydoc, update);

  // get the latest graph JSON from Yjs pointer
  const graphJSON = ymap.get("graph");

  if (graphJSON) {
    // update pointer to 
    applyingRemoteUpdate = true;
    graph.configure(graphJSON);
    graph._graph_cache = graph.serializeDeep({ skip_inputs:true, skip_outputs:true, skip_properties:true });
    applyingRemoteUpdate = false;
  }
}; 

// given a json, applies remote (full graph)
window.temp_remote_update = function(json) {
  applyingRemoteUpdate = true;
  graph.configure(json); 
  graph._graph_cache = graph.serializeDeep({ skip_inputs:true, skip_outputs:true, skip_properties:true });
  applyingRemoteUpdate = false;
};

// demo nodes
function sum(a,b){ return a+b; }
LiteGraph.wrapFunctionAsNode("math/sum", sum, ["Number","Number"], "Number");

var n1 = LiteGraph.createNode("math/sum"); n1.pos=[200,200]; graph.add(n1);
var n2 = LiteGraph.createNode("math/sum"); n2.pos=[400,200]; graph.add(n2);

/*
function freezeGraph() {
  const overlay = document.getElementById("overlay");
  overlay.style.display = "block";
}

function unfreezeGraph(){ 
  const overlay = document.getElementById("overlay");
  overlay.style.display = "none";
}
*/

const historyBtn = document.getElementById("historyBtn");
const historyPanel = document.getElementById("historyPanel");
const historyList = document.getElementById("historyList");
const restoreButton = document.getElementById("restore");

historyBtn.addEventListener("click", () => {
    if (historyPanel.style.display == "block") {
      // if we're closing the history, reverting to current state 
      let currentPreview = null
      historyPanel.style.display = "none";
      console.log("History button Unpressed.")
      document.dispatchEvent(new CustomEvent("getCurrent", {})) 
    }
    else { 
      // opening history, render the history
      historyPanel.style.display = "block"; 
      document.dispatchEvent(new CustomEvent("historyRequest", {}))  
      console.log("History button pressed.");
  }
});

// restores history request on button click
restoreButton.addEventListener("click", () => {  
  if (currentPreview!= null) { 
    console.log(currentPreview);
    historyPanel.style.display = "none";
    document.dispatchEvent(new CustomEvent("restore-version", { detail: currentPreview }))  
  }

})

  // function to render versions (same as collab list)
  window.renderHistory = function(versions) {
    historyList.innerHTML = "";
    versions.forEach((version, index) => {
      const li = document.createElement("li");
      li.textContent = `Version ${index + 1} (${new Date(version.timestamp).toLocaleTimeString()})`;
      li.style.cursor = "pointer";
      li.onclick = () => {
        console.log("Requesting version", index); 
        currentPreview = index
        document.dispatchEvent(new CustomEvent("loadVersion", { detail: index }));
      };
      historyList.appendChild(li);
    });
  }

// restores history
window.restore = function(graphJSON) {
    applyingRemoteUpdate = true;
    canvas.graph.clear();
    canvas.graph.configure(graphJSON);
    ymap.set("graph", deepClone(graphJSON));
    canvas.graph._graph_cache = canvas.graph.serializeDeep({ skip_inputs:true, skip_outputs:true, skip_properties:true });
    applyingRemoteUpdate = false;
};

// join button
document.getElementById("joinRoomBtn").addEventListener("click", ()=>{
  userId = document.getElementById("userId").value.trim();
  roomId = document.getElementById("roomId").value.trim();
  if(!userId || !roomId) { alert("Enter User ID and Room ID"); return; }

  alert(`You are now joining room ${roomId} as user ${userId}`);
});
</script>
<script src="app.js"></script>
</body></html>
